<html>
    <head>
        <title>tskit_arg_visualizer</title>
        <meta charset="utf-8">
        <script defer src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
        <script src='https://cdn.rawgit.com/eligrey/canvas-toBlob.js/f1a01896135ab378aa5c0118eadd81da55e698d8/canvas-toBlob.js'></script>
        <script src='https://cdn.rawgit.com/eligrey/FileSaver.js/e9d941381475b5df8b7d7691013401e171014e89/FileSaver.min.js'></script>
        <script src='https://d3js.org/d3.v7.min.js'></script>

        <style>
            .d3arg {
                position: relative;
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                background-color: white;
                padding: 20px 20px 60px 20px;
            }

            .d3arg:hover .dashboard {
                visibility: visible;
            }

            .dashboard {
                display: flex;
                visibility: hidden;
            }

            .dashboard .dashbutton {
                position: relative;
                font-size: 30px;
                border: 0px;
                background-color: white;
                width: 30px;
                height: 30px;
            }

            .dashboard .dashbutton .tip {
                width: 120px;
                font-size: 12px;
                background-color: lightgrey;
                color: #053e4e;
                text-align: center;
                padding: 5px 0px;
                position: absolute;
                z-index: 1;
                top: 100%;
                left: 50%; 
                margin-left: -60px;
                visibility: hidden;
            }

            .dashboard .dashbutton:hover .desc {
                visibility: visible;
            }

            .dashboard path {
                fill: grey;
            }

            .dashboard .dashbutton:hover path {
                fill: #053e4e;
            }

            .dashboard .activecolor:active path {
                fill: #1eebb1;
            }

            .savemethods {
                display: flex;
                justify-content: center;
                align-items: center;
                flex-direction: row;
                flex-wrap: wrap;
            }

            .savemethods button {
                background-color: lightgrey;
                color: #053e4e;
                font-size: 12px;
                width: auto;
                border: none;
            }

            .savemethods button:hover {
                color: #1eebb1;
            }


            .yaxis path {
                stroke: #053e4e;
                stroke-width: 3px;
            }

            .yaxis line {
                stroke: #053e4e;
                stroke-width: 3px;
            }

            .yaxis text {
                fill: #053e4e;
                stroke: 1px;
            }

            .node {
                fill: #1eebb1;
                stroke: #053e4e;
                stroke-width: 4px;
            }

            .hiddennode {
                fill: lightgrey;
                stroke: lightgrey;
                stroke-width: 4px;
            }

            .underlink {
                stroke: #ffffff;
                stroke-width: 12px;
                fill: none;
            }

            .link {
                stroke: #053e4e;
                stroke-width: 4px;
                fill: none;
            }

            .hiddenlink {
                stroke: lightgrey;
                stroke-width: 4px;
                fill: none;
            }

            .labels {
                text-anchor: middle;
            }

            .label {
                fill: #053e4e;
                font-family: Arial;
                font-size: 12px;
            }

            .hiddenlabel {
                fill: lightgrey;
                font-family: Arial;
                font-size: 12px;
            }

            svg {
                display: block;
            }

            button {
                display: block;
                cursor: pointer;
            }

            .saving {
                display: flex;
                flex-direction: row;
            }

            .saving .message {
                display: none;
            }

            .box {
                width: 550px;
                height: 575px;
                display: flex;
                justify-content: center;
                align-items: center;
            }

            .loader {
                margin: auto;
                border: 20px solid #053e4e;
                border-radius: 50%;
                border-top: 20px solid #1eebb1;
                width: 100px;
                height: 100px;
                animation: spinner 4s linear infinite;
            }

            @keyframes spinner {
                0% { transform: rotate(0deg); }
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>
    <body>
        <script>
            var line = d3.line();
            var step = d3.line().curve(d3.curveStep);
            var stepAfter = d3.line().curve(d3.curveStepAfter);
            var stepBefore = d3.line().curve(d3.curveStepBefore);

            function displayArg() {
                document.getElementById("output").innerHTML = "";

                let arg_d3 = generate_random_arg().toJs();

                let nodes = [];
                for (var x = 0; x < arg_d3.get("arg").get("nodes").length; x++) {
                    let node = new Object();
                    for (let [key, value] of arg_d3.get("arg").get("nodes")[x]) {
                        node[key] = value;
                    }
                    nodes.push(node);
                }

                let links = [];
                for (var x = 0; x < arg_d3.get("arg").get("links").length; x++) {
                    let link = new Object();
                    for (let [key, value] of arg_d3.get("arg").get("links")[x]) {
                        if ((key == "source") | (key  == "target")) {
                            link[key] = nodes.find(obj=>{return obj.id==value});
                        } else {
                            link[key] = value;
                        }
                    }
                    links.push(link);
                }

                var svg = d3.select("#output").append("svg")
                    .attr("width", arg_d3.get("width"))
                    .attr("height", arg_d3.get("height"))
                    .style("background-color", "white");

                var simulation = d3
                    .forceSimulation(nodes)
                    .force("link", d3.forceLink()
                        .links(links)
                    )
                    .force("charge", d3.forceManyBody().strength(-10))
                    .on("tick", ticked);

                var link_container = svg
                    .append("g")
                    .attr("class", "links")
                    .selectAll("path")
                    .data(links)
                    .enter()
                    .append("g")
                    .attr("bounds", function(d) {
                        return d.bounds;
                    });

                var link = link_container
                    .append("path")
                    .attr("class", "link");

                var node = svg
                    .append("g")
                    .attr("class", "nodes")
                    .selectAll("circle")
                    .data(nodes)
                    .enter()
                    .append("circle")
                    .attr("class", "node")
                    .attr("r", 7)
                    .call(
                        d3
                            .drag()
                            .on("start", dragstarted)
                            .on("drag", dragged)
                    );
                
                var label = svg
                    .append("g")
                    .attr("class", "labels")
                    .selectAll("text")
                    .data(nodes)
                    .enter()
                    .append("text")
                        .attr("class", "label")
                        .text(function (d) { return d.label; });

                function determine_label_positioning(d) {
                    if (d.flag == 131072 || d.parent_of.length == 0 || d.child_of.length == 0) {
                        return "c";
                    } else if (d.child_of.length == 1) {
                        var parent = document.getElementById("node" + d.child_of[0])
                        if (parent != null) {
                            var parent_x = parent.getAttribute("cx");
                            if (parent_x > d.x) {
                                return "l";
                            } else {
                                return "r";
                            }
                        } else {
                            return "r";
                        }
                    } else {
                        return "r";
                    }
                };

                function ticked() {

                    node
                        .attr("cx", function(d) {
                            if (arg_d3.get("y_axis").get("include_labels") == "false") {
                                return d.x = Math.max(50, Math.min(arg_d3.get("width")-50, d.x));
                            } else {
                                return d.x = Math.max(100, Math.min(arg_d3.get("width")-50, d.x));
                            }
                        })
                        .attr("cy", function(d) {
                            return d.y;
                        });

                    link
                        //.attr("path_type", function(d) {
                        //    return determine_path_type(d)[0];
                        //})
                        .attr("d", function(d) {
                            if (arg_d3.get("edge_type") == "ortho") {
                                const output = determine_path_type(d);
                            
                                const path_type = output[0];
                                const simple_path_type = Array.from(path_type)[0] + Array.from(path_type)[2];
                                const start_position_x = output[1];
                                const start_position_y = output[2];
                                const stop_position_x = output[3];
                                const stop_position_y = output[4];

                                const after_paths = ["rf", "tb", "tf"];
                                const before_paths = ["rt", "fb", "ft"];
                                const step_paths = ["tt"];
                                const mid_paths = ["rb", "ff"];

                                if (after_paths.includes(simple_path_type)) {
                                    return line([[d.source.x, d.source.y],[start_position_x, start_position_y]]) + stepAfter([[start_position_x, start_position_y],[stop_position_x, stop_position_y]]) + line([[stop_position_x, stop_position_y], [d.target.x, d.target.y]]);
                                } else if (before_paths.includes(simple_path_type)) {
                                    return line([[d.source.x, d.source.y],[start_position_x, start_position_y]]) + stepBefore([[start_position_x, start_position_y],[stop_position_x, stop_position_y]]) + line([[stop_position_x, stop_position_y], [d.target.x, d.target.y]]);
                                } else if (step_paths.includes(simple_path_type)) {
                                    return line([[d.source.x, d.source.y],[start_position_x, start_position_y]]) + step([[start_position_x, start_position_y],[stop_position_x, stop_position_y]]) + line([[stop_position_x, stop_position_y], [d.target.x, d.target.y]]);
                                } else if (mid_paths.includes(simple_path_type)) {
                                    return line([[d.source.x, d.source.y],[start_position_x, start_position_y]]) + line([[start_position_x, start_position_y],[start_position_x, start_position_y + (stop_position_y - start_position_y)/2]]) + line([[start_position_x, start_position_y + (stop_position_y - start_position_y)/2],[stop_position_x, start_position_y + (stop_position_y - start_position_y)/2]]) + line([[stop_position_x, start_position_y + (stop_position_y - start_position_y)/2], [stop_position_x, stop_position_y]]) + line([[stop_position_x, stop_position_y], [d.target.x, d.target.y]]);
                                }
                            } else if (arg_d3.get("edge_type") == "line") {
                                if (d.source.id == d.alt_parent) {
                                    var leftOrRight = 20;
                                    if (d.index % 2 == 0) {
                                        leftOrRight = -20;
                                    }
                                    return "M " + d.source.x + " " + d.source.y + " C " + (d.source.x + leftOrRight).toString() + " " +  (d.source.y - 10).toString() + ", " + (d.target.x + leftOrRight).toString() + " " + (d.target.y + 10).toString() + ", " + d.target.x + " " + d.target.y;
                                } else {
                                    return line([[d.source.x, d.source.y], [d.target.x, d.target.y]]);
                                }
                            }
                        });

                    label
                        .attr("x", function(d) {
                            var positioning = determine_label_positioning(d);
                            if (positioning == "l") {
                                return d.x - 15;
                            } else if (positioning == "r") {
                                return d.x + 15;
                            } else {
                                return d.x;
                            }
                        })
                        .style("text-anchor", function(d) {
                            var positioning = determine_label_positioning(d);
                            if (positioning == "l") {
                                return "end";
                            } else if (positioning == "r") {
                                return "start";
                            } else {
                                return "middle";
                            }
                        })
                        .attr("y", function(d) {
                            if (d.parent_of.length == 0) {
                                return d.y + 25;
                            } else {
                                return d.y - 15;
                            }
                        });

                }

                function dragstarted(event, d) {
                    if (!event.active) simulation.alphaTarget(0.3).restart();
                    d.fx = d.x;
                }

                function dragged(event, d) {
                    d.fx = event.x;
                }
            }
        </script>

        <button onclick="displayArg();">Generate ARG</button>
        <div id="output" class="d3arg">
            <div class="box">
                <div class="loader"></div>
            </div>
        </div>
        <script type="module">
            // https://gist.github.com/Rokotyan/0556f8facbaf344507cdc45dc3622177
            // Below are the functions that handle actual exporting:
            // getSVGString ( svgNode ) and svgString2Image( svgString, width, height, format, callback )
            function getSVGString( svgNode ) {
                svgNode.setAttribute('xlink', 'http://www.w3.org/1999/xlink');
                var cssStyleText = getCSSStyles();
                appendCSS( cssStyleText, svgNode );
                var serializer = new XMLSerializer();
                var svgString = serializer.serializeToString(svgNode);
                svgString = svgString.replace(/(\w+)?:?xlink=/g, 'xmlns:xlink='); // Fix root xlink without namespace
                svgString = svgString.replace(/NS\d+:href/g, 'xlink:href'); // Safari NS namespace fix
                return svgString;

                function getCSSStyles() {
                    // Extract CSS Rules
                    var extractedCSSText = "";
                    for (var i = 0; i < document.styleSheets.length; i++) {
                        var s = document.styleSheets[i];
                        try {
                            if(!s.cssRules) continue;
                        } catch( e ) {
                            if(e.name !== 'SecurityError') throw e; // for Firefox
                            continue;
                        }
                        var cssRules = s.cssRules;
                        for (var r = 0; r < cssRules.length; r++) {
                            extractedCSSText += cssRules[r].cssText;
                        }
                    }
                    return extractedCSSText;

                }

                function appendCSS( cssText, element ) {
                    var styleElement = document.createElement("style");
                    styleElement.setAttribute("type","text/css"); 
                    styleElement.innerHTML = cssText;
                    var refNode = element.hasChildNodes() ? element.children[0] : null;
                    element.insertBefore( styleElement, refNode );
                }
            }


            function svgString2Image( svgString, width, height, format, callback ) {
                var format = format ? format : 'png';
                var imgsrc = 'data:image/svg+xml;base64,'+ btoa( unescape( encodeURIComponent( svgString ) ) ); // Convert SVG string to data URL
                var canvas = document.createElement("canvas");
                var context = canvas.getContext("2d");
                canvas.width = width;
                canvas.height = height;
                var image = new Image();
                image.onload = function() {
                    context.clearRect ( 0, 0, width, height);
                    context.drawImage(image, 0, 0, width, height);
                    canvas.toBlob( function(blob) {
                        var filesize = Math.round( blob.length/1024 ) + ' KB';
                        if ( callback ) callback( blob, filesize );
                    });
                };
                image.src = imgsrc;
            }


            const pyodide = await loadPyodide();
            await pyodide.loadPackage(["msprime", "numpy"]);
            const msprime = await pyodide.pyimport("msprime");
            const numpy = await pyodide.pyimport("numpy");

            pyodide.runPython(`
                import numpy as np
                import random
                import math
                import os
                from string import Template
                import msprime
                import js

                def calculate_evenly_distributed_positions(num_elements, start=0, end=1):
                    """Returns a list of 'num_elements' evenly distributed positions on a given 'length'

                    Parameters
                    ----------
                    num_elements : int
                        Number of positions to be returned
                    length : int or float
                        Range of positions

                    Returns
                    -------
                    List of float positions
                    """

                    if num_elements > 1:
                        w_spacing = (end-start) / (num_elements - 1)
                        return [i * w_spacing + start for i in range(num_elements)]
                    else:
                        return [0.5 * (end-start) + start]

                class D3ARG:
                    """Stores the ARG in a D3.js friendly format ready for plotting

                    See 'Alternative Constructors' for common ways of creating this object

                    Attributes
                    ----------
                    nodes : list
                        List of node dicts that contain info about the nodes
                    edges : list
                        List of edge dicts that contain info about the edges
                    breakpoints : list
                        List of breakpoint dicts that contain info about the breakpoints
                    num_samples : int
                        The number of samples in the ARG (with flag=1)
                    sample_order : list
                        Ordered list of sample IDs

                    Alternative Constructors
                    ------------------------
                    from_ts(ts)
                        Creates a D3ARG from a tskit.TreeSequence
                    
                    from_json(json)
                        Creates a D3ARG from a saved custom JSON

                    Methods
                    -------
                    draw(
                        width=500,
                        height=500,
                        tree_highlighting=True,
                        y_axis_labels=True,
                        y_axis_scale="rank",
                        line_type="ortho",
                        subset_nodes=[],
                        include_node_labels=True
                    )
                        Draws the ARG using D3.js

                    set_node_labels(labels={})
                        Customizes node labels in visualization

                    reset_node_labels()
                        Sets the node labels back to default values

                    """

                    def __init__(self, nodes, edges, breakpoints, num_samples, sample_order):
                        """Initializes a D3ARG object

                        This is the generalized function for initializing a D3ARG object. It is most
                        often called by another method, such as from_ts() or from_json(), though it
                        can be used separately if the parameters are in the correct format.

                        Parameters
                        ----------
                        nodes : list
                            List of node dicts that contain info about the nodes
                        edges : list
                            List of edge dicts that contain info about the edges
                        breakpoints : list
                            List of breakpoint dicts that contain info about the breakpoints
                        num_samples : int
                        sample_order : list or np.array
                        """

                        self.nodes = nodes
                        self.edges = edges
                        self.breakpoints = breakpoints
                        self.num_samples = num_samples
                        self.sample_order = sample_order
                        
                    @classmethod
                    def from_ts(cls, ts):
                        """Converts a tskit tree sequence into a D3ARG object
                        
                        Parameters
                        ----------
                        ts : tskit.TreeSequence
                            tree sequence must have marked recombination nodes, such as using
                            msprime.sim_ancestry(...,record_full_arg=True)
                        
                        Returns
                        -------
                        D3ARG : a corresponding D3ARG object ready to be plotted
                        """

                        rcnm = np.where(ts.tables.nodes.flags == 131072)[0][1::2]
                        ordered_nodes = [] # Ordering of sample nodes is the same as the first tree in the sequence
                        for node in ts.first().nodes(order="minlex_postorder"):
                            if node < ts.num_samples:
                                ordered_nodes.append(node)
                        return cls(
                            nodes=cls._convert_nodes_table(ts=ts, recombination_nodes_to_merge=rcnm),
                            edges=cls._convert_edges_table(ts=ts, recombination_nodes_to_merge=rcnm),
                            breakpoints=cls._identify_breakpoints(ts=ts),
                            num_samples=ts.num_samples,
                            sample_order=ordered_nodes
                        )
                    
                    @classmethod
                    def from_json(cls, json):
                        """Converts a saved custom JSON into the D3ARG object
                        
                        Parameters
                        ----------
                        json : list of dictionaries
                            the custom output of that is copied to clipboard within the visualizer.
                            See plotting.md for more details on the format of the json structure

                        Returns
                        -------
                        D3ARG : a corresponding D3ARG object ready to be plotted
                        """

                        samples = []
                        samples_x_pos = []
                        nodes = json["arg"]["nodes"]
                        width = json["width"]
                        x_shift = 50
                        if json["y_axis"]["include_labels"]:
                            x_shift = 100
                            width -= 50
                        for i,node in enumerate(nodes):
                            if node["flag"] == 1:
                                samples.append(node["id"])
                                samples_x_pos.append(node["fx"])
                            nodes[i]["x_pos_01"] = (node["x"] - x_shift) / (width-100)
                        return cls(
                            nodes=nodes,
                            edges=json["arg"]["links"],
                            breakpoints=json["arg"]["breakpoints"],
                            num_samples=len(samples),
                            sample_order=[sample for _, sample in sorted(zip(samples_x_pos, samples))]
                        )

                    def _convert_nodes_table(ts, recombination_nodes_to_merge):
                        """Creates nodes JSON from the tskit.TreeSequence nodes table
                        
                        A "reference" is the id of another node that is used to determine a property in the
                        graph. Example: recombination nodes should have the same x position as their child, unless their child is
                        also a recombination node. This isn't yet implemented automatically in the layout as it breaks the force
                        layout.

                        Parameters
                        ----------
                        ts : tskit.TreeSequence
                            tree sequence must have marked recombination nodes, such as using
                            msprime.sim_ancestry(...,record_full_arg=True)
                        recombination_nodes_to_merge : list or numpy.Array
                            IDs of recombination nodes that need to be converted to their alternate ID

                        Returns
                        -------
                        nodes : list
                            List of dictionaries containing information about a given node
                        """

                        # Parameters for the dimensions of the D3 plot. Eventually want to handle this entirely in JS
                        h_spacing = 1 / (len(np.unique(ts.tables.nodes.time))-1) #(ts.num_nodes - ts.num_samples - np.count_nonzero(ts.tables.nodes.flags == 131072)/2)
                        ordered_nodes = [] # Ordering of sample nodes is the same as the first tree in the sequence
                        for node in ts.first().nodes(order="minlex_postorder"):
                            if node < ts.num_samples:
                                ordered_nodes.append(node)
                        unique_times = list(np.unique(ts.tables.nodes.time)) # Determines the rank (y position) of each time point 
                        nodes = []
                        for ID, node in enumerate(ts.tables.nodes):
                            child_of = list(np.unique(ts.tables.edges[np.where(ts.tables.edges.child == ID)[0]].parent))
                            for i,child in enumerate(child_of):
                                if child in recombination_nodes_to_merge:
                                    child_of[i] -= 1
                            parent_of = list(np.unique(ts.tables.edges[np.where(ts.tables.edges.parent == ID)[0]].child))
                            for i,parent in enumerate(parent_of):
                                if parent in recombination_nodes_to_merge:
                                    parent_of[i] -= 1
                            info = {
                                "id": ID,
                                "flag": node.flags,
                                "time": node.time,
                                "time_01":1-node.time/ts.max_root_time,
                                "logtime_01":1-math.log(node.time+1)/math.log(ts.max_root_time),
                                "rank_01": 1-(unique_times.index(node.time)*h_spacing), #fixed y position, property of force layout
                                "child_of": list(np.unique(child_of)),
                                "parent_of": list(np.unique(parent_of))
                            }
                            label = ID
                            if node.flags == 131072:
                                if ID in recombination_nodes_to_merge:
                                    continue
                                label = str(ID)+"/"+str(ID+1)
                                if len(parent_of) > 0:
                                    info["x_pos_reference"] = parent_of[0]
                            elif node.flags == 262144:
                                if len(parent_of) > 0:
                                    info["x_pos_reference"] = parent_of[0]
                            info["label"] = str(label) #label which is either the node ID or two node IDs for recombination nodes
                            nodes.append(info)
                        return nodes

                    def _convert_edges_table(ts, recombination_nodes_to_merge):
                        """Creates edges JSON from the tskit.TreeSequence edges table

                        Merges the recombination nodes, identified by the smaller of the two IDs. The direction
                        that the edge should go relates to the positions of not just the nodes connected by that edge, but also the
                        other edges connected to the child. See the JS for all of the different scenarios; still working through
                        that.

                        Parameters
                        ----------
                        ts : tskit.TreeSequence
                            tree sequence must have marked recombination nodes, such as using
                            msprime.sim_ancestry(...,record_full_arg=True)
                        recombination_nodes_to_merge : list or numpy.Array
                            IDs of recombination nodes that need to be converted to their alternate ID

                        Returns
                        -------
                        links : list
                            List of dictionaries containing information about a given link
                        """

                        parents = list(ts.edges_parent)
                        for i,parent in enumerate(parents):
                            if parent in recombination_nodes_to_merge:
                                parents[i] -= 1

                        uniq_child_parent = np.unique(np.column_stack((ts.edges_child, parents)), axis=0) #Find unique parent-child pairs.
                        links = []
                        for combo in uniq_child_parent:
                            child = combo[0]
                            parent = combo[1]
                            equivalent_edges = ts.tables.edges[np.where((ts.edges_child == child) & (parents == parent))[0]]
                            region_size = 0
                            bounds = ""
                            for edge in equivalent_edges:
                                bounds += f"{edge.left}-{edge.right} "
                                region_size += edge.right - edge.left
                            alternative_child = ""
                            alternative_parent = ""
                            if ts.tables.nodes.flags[parent] != 131072:
                                children = np.unique(ts.tables.edges[np.where(parents == parent)[0]].child)
                                if len(children) > 2:
                                    alternative_child = children[np.where(children != child)][0]
                                elif len(children) > 1:
                                    alternative_child = children[np.where(children != child)][0]
                                else:
                                    alternative_child = -1 # this occurs when converting from SLiM simulations, needs to have better handling
                                if alternative_child in recombination_nodes_to_merge:
                                    alternative_child -= 1
                            elif parent in recombination_nodes_to_merge:
                                parent = edge.parent - 1
                            if ts.tables.nodes.flags[child] == 131072:
                                if child in recombination_nodes_to_merge:
                                    alt_id = child - 1
                                else:
                                    alt_id = child + 1
                                alt_id_parents = ts.tables.edges[np.where(ts.tables.edges.child == alt_id)[0]].parent
                                if len(alt_id_parents):
                                    alternative_parent = alt_id_parents[0]
                                else:
                                    alternative_parent = ""
                            if child in recombination_nodes_to_merge:
                                child = child - 1
                            links.append({
                                    "source": int(parent),
                                    "target": int(child),
                                    "bounds": bounds[:-1],
                                    "alt_parent": alternative_parent, #recombination nodes have an alternative parent
                                    "alt_child": alternative_child,
                                    "region_fraction": region_size / ts.sequence_length
                                })
                        return links
                    
                    def _identify_breakpoints(ts):
                        """Creates breakpoints JSON from the tskit.TreeSequence

                        Parameters
                        ----------
                        ts : tskit.TreeSequence
                            tree sequence must have marked recombination nodes, such as using
                            msprime.sim_ancestry(...,record_full_arg=True)
                        
                        Returns
                        -------
                        breakpoints : list
                            List of dictionaries containing information about breakpoints
                        """
                        
                        breakpoints = []
                        start = 0
                        for bp in ts.breakpoints():
                            if bp != 0:
                                breakpoints.append({
                                    "start": start,
                                    "stop": bp,
                                    "x_pos_01":(start/ts.sequence_length),
                                    "width_01":((bp - start)/ts.sequence_length)
                                })
                                start = bp
                        return breakpoints

                    def set_node_labels(self, labels):
                        """Sets custom node labels

                        Updates node labels based on the D3ARG node "id" using the labels dictionary.
                        Final labels will always be strings. Do not rely on the ordering of the
                        labels dictionary.

                        Parameters
                        ----------
                        labels : dict
                            ID of the node and its new label
                        """

                        id_map = {n["id"]: i for i,n in enumerate(self.nodes)}
                        for label in labels:
                            if label not in id_map:
                                raise ValueError(f"Node '{label}' not in the graph. Cannot update the node label.")
                            self.nodes[id_map[label]]["label"] = str(labels[label])

                    def reset_node_labels(self):
                        """Resets node labels to default (based on msprime IDs)"""

                        for node in self.nodes:
                            if node["flag"] == 131072:
                                node["label"] = str(node["id"]) + "/" + str(node["id"]+1)
                            else:
                                node["label"] = str(node["id"])
                    
                    def _check_all_nodes_are_samples(self, nodes):
                        """Checks whether the list of nodes includes only samples

                        Returns False
                        
                        Parameter
                        ---------
                        nodes : list
                            List of potential sample nodes

                        Returns
                        -------
                        tuple :
                            bool : whether all nodes in list are samples
                            int/None : the ID of the first node that is not a sample
                        """

                        id_map = {n["id"]: i for i,n in enumerate(self.nodes)}
                        for node in nodes:
                            if id_map.get(node,-1) != -1:
                                if self.nodes[id_map[node]]["flag"] != 1:
                                    return False, node
                            else:
                                raise ValueError(f"Node '{node}' not in the graph.")
                        return True, None

                    def draw(
                            self,
                            width=500,
                            height=500,
                            tree_highlighting=True,
                            y_axis_labels=True,
                            y_axis_scale="rank",
                            edge_type="line",
                            variable_edge_width=False,
                            subset_nodes=None,
                            include_node_labels=True
                        ):
                        """Draws the D3ARG using D3.js by sending a custom JSON object to visualizer.js 

                        Parameters
                        ----------
                        width : int
                            Width of the force layout graph plot in pixels (default=500)
                        height : int
                            Height of the force layout graph plot in pixels (default=500)
                        tree_highlighting : bool
                            Include the interactive chromosome at the bottom of the figure to
                            to let users highlight trees in the ARG (default=True)
                        y_axis_labels : bool
                            Includes labelled y-axis on the left of the figure (default=True)
                        y_axis_scale : string
                            Scale used for the positioning nodes along the y-axis. Options:
                                "rank" (default) - equal vertical spacing between nodes
                                "time" - vertical spacing is proportional to the time
                                "log_time" - proportional to the log of time
                        edge_type : string
                            Pathing type for edges between nodes. Options:
                                "line" (default) - simple straight lines between the nodes
                                "ortho" - custom pathing (see pathing.md for more details, should only be used with full ARGs)
                        variable_edge_width : bool
                            Scales the stroke width of edges in the visualization will be proportional to the fraction of
                            sequence in which that edge is found. (default=False)
                        subset_nodes : list (EXPERIMENTAL)
                            List of nodes that user wants to stand out within the ARG. These nodes and the edges between them
                            will have full opacity; other nodes will be faint (default=None, parameter is ignored and all
                            nodes will have opacity)
                        include_node_labels : bool
                            Includes the node labels for each node in the ARG (default=True)
                        """
                        
                        y_axis_ticks = []
                        y_axis_text = []
                        transformed_nodes = []
                        
                        x_shift = 50
                        if y_axis_labels:
                            x_shift = 100
                        sample_positions = calculate_evenly_distributed_positions(num_elements=self.num_samples, start=x_shift, end=(width-100)+x_shift)

                        for node in self.nodes:
                            if node.get("x_pos_01", -1) != -1:
                                node["fx"] = node["x_pos_01"] * (width-100) + x_shift
                            elif node["flag"] == 1:
                                node["fx"] = sample_positions[self.sample_order.index(node["id"])]
                            else:
                                node["x"] = 0.5 * (width-100) + x_shift
                            if y_axis_scale == "time":
                                node["fy"] = node["time_01"] * (height-100) + 50
                                y_axis_ticks.append(node["time_01"] * (height-100) + 50)
                            elif y_axis_scale == "log_time":
                                node["fy"] = node["logtime_01"] * (height-100) + 50
                                y_axis_ticks.append(node["logtime_01"] * (height-100) + 50)
                            else:
                                node["fy"] = node["rank_01"] * (height-100) + 50
                                y_axis_ticks.append(node["rank_01"] * (height-100) + 50)
                            node["y"] = node["fy"]
                            y_axis_text.append(node["time"])
                            transformed_nodes.append(node)
                        y_axis_text = [round(t) for t in set(y_axis_text)]
                        if tree_highlighting:
                            height += 75
                        transformed_bps = []
                        for bp in self.breakpoints:
                            if y_axis_labels:
                                bp["x_pos"] = bp["x_pos_01"] * width + 50
                            else:
                                bp["x_pos"] = bp["x_pos_01"] * width
                            bp["width"] = bp["width_01"] * width
                            transformed_bps.append(bp)
                        if y_axis_labels:
                            width += 50
                        if not subset_nodes:
                            subset_nodes = [node["id"] for node in self.nodes]
                        arg = {
                            "arg":{
                                "nodes":transformed_nodes,
                                "links":self.edges,
                                "breakpoints": transformed_bps
                            },
                            "width":width,
                            "height":height,
                            "y_axis":{
                                "include_labels":str(y_axis_labels).lower(),
                                "ticks":sorted(list(set(y_axis_ticks)), reverse=True),
                                "text":sorted(list(y_axis_text)),
                                "max_min":[max(y_axis_ticks),min(y_axis_ticks)],
                                "scale":y_axis_scale,
                            },
                            "tree_highlighting":str(tree_highlighting).lower(),
                            "edge_type": edge_type,
                            "variable_edge_width": str(variable_edge_width).lower(),
                            "subset_nodes": subset_nodes,
                            "include_node_labels": str(include_node_labels).lower(),
                            "evenly_distributed_positions": sample_positions
                        }
                        return arg

                def generate_random_arg():
                    # Generate a random tree sequence with record_full_arg=True so that you get marked recombination nodes
                    rs = random.randint(0, 10000)   
                    ts = msprime.sim_ancestry(samples=random.randint(1,5), recombination_rate=1e-8,sequence_length=3000, population_size=10000, record_full_arg=True, random_seed=rs)
                    d3arg = D3ARG.from_ts(ts=ts)
                    return d3arg.draw()

                js.generate_random_arg = generate_random_arg
            `);
            
            displayArg();
        </script>
    </body>
</html>